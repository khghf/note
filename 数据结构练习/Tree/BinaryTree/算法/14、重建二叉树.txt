给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。pre 和 vin 均无重复元素
 TreeNode* reConstructBinaryTree(vector<int>& preOrder, vector<int>& vinOrder) {
        // write code here
        int n=preOrder.size();
        int m=vinOrder.size();
        if(n==0||m==0)return nullptr;
        TreeNode*root=new TreeNode(preOrder[0]);
        //前序遍历为根左右所以第一个结点为根节点
        //中序遍历为左根右
        //因此可以从前序中确定根节点，再用根结点在中序中确定左右子树

        for(int i=0;i<vinOrder.size();i++)
        {
            if(preOrder[0]==vinOrder[i])
            {
                vector<int>leftpre(preOrder.begin()+1,preOrder.begin()+1+i);
                vector<int>leftvin(vinOrder.begin(),vinOrder.begin()+i);
                root->left=reConstructBinaryTree(leftpre, leftvin);
                vector<int>rightpre(preOrder.begin()+i+1,preOrder.end());
                vector<int>rightvin(vinOrder.begin()+i+1,vinOrder.end());
                root->right=reConstructBinaryTree(rightpre, rightvin);
                break;
            }
        }
        return root;
    }
二、
TreeNode*build(vector<int>& preOrder,int pl,int pr,vector<int>& inOrder,int il,int ir)
    {
        TreeNode*root=nullptr;
        for(int i=il;i<=ir;i++)
        {
                if(inOrder[i]==preOrder[pl])
                {
                    //找到根节点
                    root=new TreeNode(preOrder[pl]);
                    int leftsize = i - il; //左子树大小
                    int rightsize = ir - i;//右子树大小
                    root->left=build(preOrder, pl+1, pl+leftsize, inOrder, il,il+leftsize-1);
                    root->right=build(preOrder, pr-rightsize+1, pr, inOrder, i+1,ir);
                    break;
                }
        }
        return root;
    }